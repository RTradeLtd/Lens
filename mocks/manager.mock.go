// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	context "context"
	io "io"
	sync "sync"
	time "time"

	shell "github.com/RTradeLtd/go-ipfs-api"
	rtfs "github.com/RTradeLtd/rtfs"
)

type FakeManager struct {
	AddStub        func(io.Reader) (string, error)
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 io.Reader
	}
	addReturns struct {
		result1 string
		result2 error
	}
	addReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CatStub        func(string) ([]byte, error)
	catMutex       sync.RWMutex
	catArgsForCall []struct {
		arg1 string
	}
	catReturns struct {
		result1 []byte
		result2 error
	}
	catReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	CheckPinStub        func(string) (bool, error)
	checkPinMutex       sync.RWMutex
	checkPinArgsForCall []struct {
		arg1 string
	}
	checkPinReturns struct {
		result1 bool
		result2 error
	}
	checkPinReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CustomRequestStub        func(context.Context, string, string, map[string]string, ...string) (*shell.Response, error)
	customRequestMutex       sync.RWMutex
	customRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]string
		arg5 []string
	}
	customRequestReturns struct {
		result1 *shell.Response
		result2 error
	}
	customRequestReturnsOnCall map[int]struct {
		result1 *shell.Response
		result2 error
	}
	DagGetStub        func(string, interface{}) error
	dagGetMutex       sync.RWMutex
	dagGetArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	dagGetReturns struct {
		result1 error
	}
	dagGetReturnsOnCall map[int]struct {
		result1 error
	}
	DagPutStub        func(interface{}, string, string) (string, error)
	dagPutMutex       sync.RWMutex
	dagPutArgsForCall []struct {
		arg1 interface{}
		arg2 string
		arg3 string
	}
	dagPutReturns struct {
		result1 string
		result2 error
	}
	dagPutReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	NodeAddressStub        func() string
	nodeAddressMutex       sync.RWMutex
	nodeAddressArgsForCall []struct {
	}
	nodeAddressReturns struct {
		result1 string
	}
	nodeAddressReturnsOnCall map[int]struct {
		result1 string
	}
	PinStub        func(string) error
	pinMutex       sync.RWMutex
	pinArgsForCall []struct {
		arg1 string
	}
	pinReturns struct {
		result1 error
	}
	pinReturnsOnCall map[int]struct {
		result1 error
	}
	PubSubPublishStub        func(string, string) error
	pubSubPublishMutex       sync.RWMutex
	pubSubPublishArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pubSubPublishReturns struct {
		result1 error
	}
	pubSubPublishReturnsOnCall map[int]struct {
		result1 error
	}
	PublishStub        func(string, string, time.Duration, time.Duration, bool) (*shell.PublishResponse, error)
	publishMutex       sync.RWMutex
	publishArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 time.Duration
		arg4 time.Duration
		arg5 bool
	}
	publishReturns struct {
		result1 *shell.PublishResponse
		result2 error
	}
	publishReturnsOnCall map[int]struct {
		result1 *shell.PublishResponse
		result2 error
	}
	StatStub        func(string) (*shell.ObjectStats, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 *shell.ObjectStats
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 *shell.ObjectStats
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) Add(arg1 io.Reader) (string, error) {
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	fake.recordInvocation("Add", []interface{}{arg1})
	fake.addMutex.Unlock()
	if fake.AddStub != nil {
		return fake.AddStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeManager) AddCalls(stub func(io.Reader) (string, error)) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeManager) AddArgsForCall(i int) io.Reader {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) AddReturns(result1 string, result2 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) AddReturnsOnCall(i int, result1 string, result2 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Cat(arg1 string) ([]byte, error) {
	fake.catMutex.Lock()
	ret, specificReturn := fake.catReturnsOnCall[len(fake.catArgsForCall)]
	fake.catArgsForCall = append(fake.catArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Cat", []interface{}{arg1})
	fake.catMutex.Unlock()
	if fake.CatStub != nil {
		return fake.CatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.catReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CatCallCount() int {
	fake.catMutex.RLock()
	defer fake.catMutex.RUnlock()
	return len(fake.catArgsForCall)
}

func (fake *FakeManager) CatCalls(stub func(string) ([]byte, error)) {
	fake.catMutex.Lock()
	defer fake.catMutex.Unlock()
	fake.CatStub = stub
}

func (fake *FakeManager) CatArgsForCall(i int) string {
	fake.catMutex.RLock()
	defer fake.catMutex.RUnlock()
	argsForCall := fake.catArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) CatReturns(result1 []byte, result2 error) {
	fake.catMutex.Lock()
	defer fake.catMutex.Unlock()
	fake.CatStub = nil
	fake.catReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CatReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.catMutex.Lock()
	defer fake.catMutex.Unlock()
	fake.CatStub = nil
	if fake.catReturnsOnCall == nil {
		fake.catReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.catReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CheckPin(arg1 string) (bool, error) {
	fake.checkPinMutex.Lock()
	ret, specificReturn := fake.checkPinReturnsOnCall[len(fake.checkPinArgsForCall)]
	fake.checkPinArgsForCall = append(fake.checkPinArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CheckPin", []interface{}{arg1})
	fake.checkPinMutex.Unlock()
	if fake.CheckPinStub != nil {
		return fake.CheckPinStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkPinReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CheckPinCallCount() int {
	fake.checkPinMutex.RLock()
	defer fake.checkPinMutex.RUnlock()
	return len(fake.checkPinArgsForCall)
}

func (fake *FakeManager) CheckPinCalls(stub func(string) (bool, error)) {
	fake.checkPinMutex.Lock()
	defer fake.checkPinMutex.Unlock()
	fake.CheckPinStub = stub
}

func (fake *FakeManager) CheckPinArgsForCall(i int) string {
	fake.checkPinMutex.RLock()
	defer fake.checkPinMutex.RUnlock()
	argsForCall := fake.checkPinArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) CheckPinReturns(result1 bool, result2 error) {
	fake.checkPinMutex.Lock()
	defer fake.checkPinMutex.Unlock()
	fake.CheckPinStub = nil
	fake.checkPinReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CheckPinReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkPinMutex.Lock()
	defer fake.checkPinMutex.Unlock()
	fake.CheckPinStub = nil
	if fake.checkPinReturnsOnCall == nil {
		fake.checkPinReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPinReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CustomRequest(arg1 context.Context, arg2 string, arg3 string, arg4 map[string]string, arg5 ...string) (*shell.Response, error) {
	fake.customRequestMutex.Lock()
	ret, specificReturn := fake.customRequestReturnsOnCall[len(fake.customRequestArgsForCall)]
	fake.customRequestArgsForCall = append(fake.customRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]string
		arg5 []string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("CustomRequest", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.customRequestMutex.Unlock()
	if fake.CustomRequestStub != nil {
		return fake.CustomRequestStub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.customRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CustomRequestCallCount() int {
	fake.customRequestMutex.RLock()
	defer fake.customRequestMutex.RUnlock()
	return len(fake.customRequestArgsForCall)
}

func (fake *FakeManager) CustomRequestCalls(stub func(context.Context, string, string, map[string]string, ...string) (*shell.Response, error)) {
	fake.customRequestMutex.Lock()
	defer fake.customRequestMutex.Unlock()
	fake.CustomRequestStub = stub
}

func (fake *FakeManager) CustomRequestArgsForCall(i int) (context.Context, string, string, map[string]string, []string) {
	fake.customRequestMutex.RLock()
	defer fake.customRequestMutex.RUnlock()
	argsForCall := fake.customRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) CustomRequestReturns(result1 *shell.Response, result2 error) {
	fake.customRequestMutex.Lock()
	defer fake.customRequestMutex.Unlock()
	fake.CustomRequestStub = nil
	fake.customRequestReturns = struct {
		result1 *shell.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CustomRequestReturnsOnCall(i int, result1 *shell.Response, result2 error) {
	fake.customRequestMutex.Lock()
	defer fake.customRequestMutex.Unlock()
	fake.CustomRequestStub = nil
	if fake.customRequestReturnsOnCall == nil {
		fake.customRequestReturnsOnCall = make(map[int]struct {
			result1 *shell.Response
			result2 error
		})
	}
	fake.customRequestReturnsOnCall[i] = struct {
		result1 *shell.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) DagGet(arg1 string, arg2 interface{}) error {
	fake.dagGetMutex.Lock()
	ret, specificReturn := fake.dagGetReturnsOnCall[len(fake.dagGetArgsForCall)]
	fake.dagGetArgsForCall = append(fake.dagGetArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("DagGet", []interface{}{arg1, arg2})
	fake.dagGetMutex.Unlock()
	if fake.DagGetStub != nil {
		return fake.DagGetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dagGetReturns
	return fakeReturns.result1
}

func (fake *FakeManager) DagGetCallCount() int {
	fake.dagGetMutex.RLock()
	defer fake.dagGetMutex.RUnlock()
	return len(fake.dagGetArgsForCall)
}

func (fake *FakeManager) DagGetCalls(stub func(string, interface{}) error) {
	fake.dagGetMutex.Lock()
	defer fake.dagGetMutex.Unlock()
	fake.DagGetStub = stub
}

func (fake *FakeManager) DagGetArgsForCall(i int) (string, interface{}) {
	fake.dagGetMutex.RLock()
	defer fake.dagGetMutex.RUnlock()
	argsForCall := fake.dagGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) DagGetReturns(result1 error) {
	fake.dagGetMutex.Lock()
	defer fake.dagGetMutex.Unlock()
	fake.DagGetStub = nil
	fake.dagGetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DagGetReturnsOnCall(i int, result1 error) {
	fake.dagGetMutex.Lock()
	defer fake.dagGetMutex.Unlock()
	fake.DagGetStub = nil
	if fake.dagGetReturnsOnCall == nil {
		fake.dagGetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dagGetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DagPut(arg1 interface{}, arg2 string, arg3 string) (string, error) {
	fake.dagPutMutex.Lock()
	ret, specificReturn := fake.dagPutReturnsOnCall[len(fake.dagPutArgsForCall)]
	fake.dagPutArgsForCall = append(fake.dagPutArgsForCall, struct {
		arg1 interface{}
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DagPut", []interface{}{arg1, arg2, arg3})
	fake.dagPutMutex.Unlock()
	if fake.DagPutStub != nil {
		return fake.DagPutStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.dagPutReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) DagPutCallCount() int {
	fake.dagPutMutex.RLock()
	defer fake.dagPutMutex.RUnlock()
	return len(fake.dagPutArgsForCall)
}

func (fake *FakeManager) DagPutCalls(stub func(interface{}, string, string) (string, error)) {
	fake.dagPutMutex.Lock()
	defer fake.dagPutMutex.Unlock()
	fake.DagPutStub = stub
}

func (fake *FakeManager) DagPutArgsForCall(i int) (interface{}, string, string) {
	fake.dagPutMutex.RLock()
	defer fake.dagPutMutex.RUnlock()
	argsForCall := fake.dagPutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeManager) DagPutReturns(result1 string, result2 error) {
	fake.dagPutMutex.Lock()
	defer fake.dagPutMutex.Unlock()
	fake.DagPutStub = nil
	fake.dagPutReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) DagPutReturnsOnCall(i int, result1 string, result2 error) {
	fake.dagPutMutex.Lock()
	defer fake.dagPutMutex.Unlock()
	fake.DagPutStub = nil
	if fake.dagPutReturnsOnCall == nil {
		fake.dagPutReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.dagPutReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) NodeAddress() string {
	fake.nodeAddressMutex.Lock()
	ret, specificReturn := fake.nodeAddressReturnsOnCall[len(fake.nodeAddressArgsForCall)]
	fake.nodeAddressArgsForCall = append(fake.nodeAddressArgsForCall, struct {
	}{})
	fake.recordInvocation("NodeAddress", []interface{}{})
	fake.nodeAddressMutex.Unlock()
	if fake.NodeAddressStub != nil {
		return fake.NodeAddressStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeAddressReturns
	return fakeReturns.result1
}

func (fake *FakeManager) NodeAddressCallCount() int {
	fake.nodeAddressMutex.RLock()
	defer fake.nodeAddressMutex.RUnlock()
	return len(fake.nodeAddressArgsForCall)
}

func (fake *FakeManager) NodeAddressCalls(stub func() string) {
	fake.nodeAddressMutex.Lock()
	defer fake.nodeAddressMutex.Unlock()
	fake.NodeAddressStub = stub
}

func (fake *FakeManager) NodeAddressReturns(result1 string) {
	fake.nodeAddressMutex.Lock()
	defer fake.nodeAddressMutex.Unlock()
	fake.NodeAddressStub = nil
	fake.nodeAddressReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeManager) NodeAddressReturnsOnCall(i int, result1 string) {
	fake.nodeAddressMutex.Lock()
	defer fake.nodeAddressMutex.Unlock()
	fake.NodeAddressStub = nil
	if fake.nodeAddressReturnsOnCall == nil {
		fake.nodeAddressReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nodeAddressReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeManager) Pin(arg1 string) error {
	fake.pinMutex.Lock()
	ret, specificReturn := fake.pinReturnsOnCall[len(fake.pinArgsForCall)]
	fake.pinArgsForCall = append(fake.pinArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Pin", []interface{}{arg1})
	fake.pinMutex.Unlock()
	if fake.PinStub != nil {
		return fake.PinStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pinReturns
	return fakeReturns.result1
}

func (fake *FakeManager) PinCallCount() int {
	fake.pinMutex.RLock()
	defer fake.pinMutex.RUnlock()
	return len(fake.pinArgsForCall)
}

func (fake *FakeManager) PinCalls(stub func(string) error) {
	fake.pinMutex.Lock()
	defer fake.pinMutex.Unlock()
	fake.PinStub = stub
}

func (fake *FakeManager) PinArgsForCall(i int) string {
	fake.pinMutex.RLock()
	defer fake.pinMutex.RUnlock()
	argsForCall := fake.pinArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) PinReturns(result1 error) {
	fake.pinMutex.Lock()
	defer fake.pinMutex.Unlock()
	fake.PinStub = nil
	fake.pinReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) PinReturnsOnCall(i int, result1 error) {
	fake.pinMutex.Lock()
	defer fake.pinMutex.Unlock()
	fake.PinStub = nil
	if fake.pinReturnsOnCall == nil {
		fake.pinReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pinReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) PubSubPublish(arg1 string, arg2 string) error {
	fake.pubSubPublishMutex.Lock()
	ret, specificReturn := fake.pubSubPublishReturnsOnCall[len(fake.pubSubPublishArgsForCall)]
	fake.pubSubPublishArgsForCall = append(fake.pubSubPublishArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PubSubPublish", []interface{}{arg1, arg2})
	fake.pubSubPublishMutex.Unlock()
	if fake.PubSubPublishStub != nil {
		return fake.PubSubPublishStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pubSubPublishReturns
	return fakeReturns.result1
}

func (fake *FakeManager) PubSubPublishCallCount() int {
	fake.pubSubPublishMutex.RLock()
	defer fake.pubSubPublishMutex.RUnlock()
	return len(fake.pubSubPublishArgsForCall)
}

func (fake *FakeManager) PubSubPublishCalls(stub func(string, string) error) {
	fake.pubSubPublishMutex.Lock()
	defer fake.pubSubPublishMutex.Unlock()
	fake.PubSubPublishStub = stub
}

func (fake *FakeManager) PubSubPublishArgsForCall(i int) (string, string) {
	fake.pubSubPublishMutex.RLock()
	defer fake.pubSubPublishMutex.RUnlock()
	argsForCall := fake.pubSubPublishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) PubSubPublishReturns(result1 error) {
	fake.pubSubPublishMutex.Lock()
	defer fake.pubSubPublishMutex.Unlock()
	fake.PubSubPublishStub = nil
	fake.pubSubPublishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) PubSubPublishReturnsOnCall(i int, result1 error) {
	fake.pubSubPublishMutex.Lock()
	defer fake.pubSubPublishMutex.Unlock()
	fake.PubSubPublishStub = nil
	if fake.pubSubPublishReturnsOnCall == nil {
		fake.pubSubPublishReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pubSubPublishReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Publish(arg1 string, arg2 string, arg3 time.Duration, arg4 time.Duration, arg5 bool) (*shell.PublishResponse, error) {
	fake.publishMutex.Lock()
	ret, specificReturn := fake.publishReturnsOnCall[len(fake.publishArgsForCall)]
	fake.publishArgsForCall = append(fake.publishArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 time.Duration
		arg4 time.Duration
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("Publish", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.publishMutex.Unlock()
	if fake.PublishStub != nil {
		return fake.PublishStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.publishReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) PublishCallCount() int {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	return len(fake.publishArgsForCall)
}

func (fake *FakeManager) PublishCalls(stub func(string, string, time.Duration, time.Duration, bool) (*shell.PublishResponse, error)) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = stub
}

func (fake *FakeManager) PublishArgsForCall(i int) (string, string, time.Duration, time.Duration, bool) {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	argsForCall := fake.publishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) PublishReturns(result1 *shell.PublishResponse, result2 error) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	fake.publishReturns = struct {
		result1 *shell.PublishResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) PublishReturnsOnCall(i int, result1 *shell.PublishResponse, result2 error) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	if fake.publishReturnsOnCall == nil {
		fake.publishReturnsOnCall = make(map[int]struct {
			result1 *shell.PublishResponse
			result2 error
		})
	}
	fake.publishReturnsOnCall[i] = struct {
		result1 *shell.PublishResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Stat(arg1 string) (*shell.ObjectStats, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeManager) StatCalls(stub func(string) (*shell.ObjectStats, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeManager) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) StatReturns(result1 *shell.ObjectStats, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 *shell.ObjectStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) StatReturnsOnCall(i int, result1 *shell.ObjectStats, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 *shell.ObjectStats
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 *shell.ObjectStats
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.catMutex.RLock()
	defer fake.catMutex.RUnlock()
	fake.checkPinMutex.RLock()
	defer fake.checkPinMutex.RUnlock()
	fake.customRequestMutex.RLock()
	defer fake.customRequestMutex.RUnlock()
	fake.dagGetMutex.RLock()
	defer fake.dagGetMutex.RUnlock()
	fake.dagPutMutex.RLock()
	defer fake.dagPutMutex.RUnlock()
	fake.nodeAddressMutex.RLock()
	defer fake.nodeAddressMutex.RUnlock()
	fake.pinMutex.RLock()
	defer fake.pinMutex.RUnlock()
	fake.pubSubPublishMutex.RLock()
	defer fake.pubSubPublishMutex.RUnlock()
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rtfs.Manager = new(FakeManager)
