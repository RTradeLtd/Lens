// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	sync "sync"

	models "github.com/RTradeLtd/Lens/models"
	search "github.com/RTradeLtd/Lens/search"
	rtfs "github.com/RTradeLtd/rtfs"
	query "github.com/ipfs/go-datastore/query"
)

type FakeSearcher struct {
	AdvancedSearchStub        func(*search.FilterOpts) ([]models.Object, error)
	advancedSearchMutex       sync.RWMutex
	advancedSearchArgsForCall []struct {
		arg1 *search.FilterOpts
	}
	advancedSearchReturns struct {
		result1 []models.Object
		result2 error
	}
	advancedSearchReturnsOnCall map[int]struct {
		result1 []models.Object
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string) ([]byte, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 []byte
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetEntriesStub        func() ([]query.Entry, error)
	getEntriesMutex       sync.RWMutex
	getEntriesArgsForCall []struct {
	}
	getEntriesReturns struct {
		result1 []query.Entry
		result2 error
	}
	getEntriesReturnsOnCall map[int]struct {
		result1 []query.Entry
		result2 error
	}
	HasStub        func(string) (bool, error)
	hasMutex       sync.RWMutex
	hasArgsForCall []struct {
		arg1 string
	}
	hasReturns struct {
		result1 bool
		result2 error
	}
	hasReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	KeywordSearchStub        func([]string) ([]models.Object, error)
	keywordSearchMutex       sync.RWMutex
	keywordSearchArgsForCall []struct {
		arg1 []string
	}
	keywordSearchReturns struct {
		result1 []models.Object
		result2 error
	}
	keywordSearchReturnsOnCall map[int]struct {
		result1 []models.Object
		result2 error
	}
	MigrateEntriesStub        func([]query.Entry, *rtfs.IpfsManager, bool) error
	migrateEntriesMutex       sync.RWMutex
	migrateEntriesArgsForCall []struct {
		arg1 []query.Entry
		arg2 *rtfs.IpfsManager
		arg3 bool
	}
	migrateEntriesReturns struct {
		result1 error
	}
	migrateEntriesReturnsOnCall map[int]struct {
		result1 error
	}
	PutStub        func(string, []byte) error
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	putReturns struct {
		result1 error
	}
	putReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSearcher) AdvancedSearch(arg1 *search.FilterOpts) ([]models.Object, error) {
	fake.advancedSearchMutex.Lock()
	ret, specificReturn := fake.advancedSearchReturnsOnCall[len(fake.advancedSearchArgsForCall)]
	fake.advancedSearchArgsForCall = append(fake.advancedSearchArgsForCall, struct {
		arg1 *search.FilterOpts
	}{arg1})
	fake.recordInvocation("AdvancedSearch", []interface{}{arg1})
	fake.advancedSearchMutex.Unlock()
	if fake.AdvancedSearchStub != nil {
		return fake.AdvancedSearchStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.advancedSearchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSearcher) AdvancedSearchCallCount() int {
	fake.advancedSearchMutex.RLock()
	defer fake.advancedSearchMutex.RUnlock()
	return len(fake.advancedSearchArgsForCall)
}

func (fake *FakeSearcher) AdvancedSearchCalls(stub func(*search.FilterOpts) ([]models.Object, error)) {
	fake.advancedSearchMutex.Lock()
	defer fake.advancedSearchMutex.Unlock()
	fake.AdvancedSearchStub = stub
}

func (fake *FakeSearcher) AdvancedSearchArgsForCall(i int) *search.FilterOpts {
	fake.advancedSearchMutex.RLock()
	defer fake.advancedSearchMutex.RUnlock()
	argsForCall := fake.advancedSearchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSearcher) AdvancedSearchReturns(result1 []models.Object, result2 error) {
	fake.advancedSearchMutex.Lock()
	defer fake.advancedSearchMutex.Unlock()
	fake.AdvancedSearchStub = nil
	fake.advancedSearchReturns = struct {
		result1 []models.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) AdvancedSearchReturnsOnCall(i int, result1 []models.Object, result2 error) {
	fake.advancedSearchMutex.Lock()
	defer fake.advancedSearchMutex.Unlock()
	fake.AdvancedSearchStub = nil
	if fake.advancedSearchReturnsOnCall == nil {
		fake.advancedSearchReturnsOnCall = make(map[int]struct {
			result1 []models.Object
			result2 error
		})
	}
	fake.advancedSearchReturnsOnCall[i] = struct {
		result1 []models.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeSearcher) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSearcher) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSearcher) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) Get(arg1 string) ([]byte, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSearcher) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeSearcher) GetCalls(stub func(string) ([]byte, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeSearcher) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSearcher) GetReturns(result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) GetReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) GetEntries() ([]query.Entry, error) {
	fake.getEntriesMutex.Lock()
	ret, specificReturn := fake.getEntriesReturnsOnCall[len(fake.getEntriesArgsForCall)]
	fake.getEntriesArgsForCall = append(fake.getEntriesArgsForCall, struct {
	}{})
	fake.recordInvocation("GetEntries", []interface{}{})
	fake.getEntriesMutex.Unlock()
	if fake.GetEntriesStub != nil {
		return fake.GetEntriesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getEntriesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSearcher) GetEntriesCallCount() int {
	fake.getEntriesMutex.RLock()
	defer fake.getEntriesMutex.RUnlock()
	return len(fake.getEntriesArgsForCall)
}

func (fake *FakeSearcher) GetEntriesCalls(stub func() ([]query.Entry, error)) {
	fake.getEntriesMutex.Lock()
	defer fake.getEntriesMutex.Unlock()
	fake.GetEntriesStub = stub
}

func (fake *FakeSearcher) GetEntriesReturns(result1 []query.Entry, result2 error) {
	fake.getEntriesMutex.Lock()
	defer fake.getEntriesMutex.Unlock()
	fake.GetEntriesStub = nil
	fake.getEntriesReturns = struct {
		result1 []query.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) GetEntriesReturnsOnCall(i int, result1 []query.Entry, result2 error) {
	fake.getEntriesMutex.Lock()
	defer fake.getEntriesMutex.Unlock()
	fake.GetEntriesStub = nil
	if fake.getEntriesReturnsOnCall == nil {
		fake.getEntriesReturnsOnCall = make(map[int]struct {
			result1 []query.Entry
			result2 error
		})
	}
	fake.getEntriesReturnsOnCall[i] = struct {
		result1 []query.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) Has(arg1 string) (bool, error) {
	fake.hasMutex.Lock()
	ret, specificReturn := fake.hasReturnsOnCall[len(fake.hasArgsForCall)]
	fake.hasArgsForCall = append(fake.hasArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Has", []interface{}{arg1})
	fake.hasMutex.Unlock()
	if fake.HasStub != nil {
		return fake.HasStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hasReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSearcher) HasCallCount() int {
	fake.hasMutex.RLock()
	defer fake.hasMutex.RUnlock()
	return len(fake.hasArgsForCall)
}

func (fake *FakeSearcher) HasCalls(stub func(string) (bool, error)) {
	fake.hasMutex.Lock()
	defer fake.hasMutex.Unlock()
	fake.HasStub = stub
}

func (fake *FakeSearcher) HasArgsForCall(i int) string {
	fake.hasMutex.RLock()
	defer fake.hasMutex.RUnlock()
	argsForCall := fake.hasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSearcher) HasReturns(result1 bool, result2 error) {
	fake.hasMutex.Lock()
	defer fake.hasMutex.Unlock()
	fake.HasStub = nil
	fake.hasReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) HasReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasMutex.Lock()
	defer fake.hasMutex.Unlock()
	fake.HasStub = nil
	if fake.hasReturnsOnCall == nil {
		fake.hasReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) KeywordSearch(arg1 []string) ([]models.Object, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.keywordSearchMutex.Lock()
	ret, specificReturn := fake.keywordSearchReturnsOnCall[len(fake.keywordSearchArgsForCall)]
	fake.keywordSearchArgsForCall = append(fake.keywordSearchArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("KeywordSearch", []interface{}{arg1Copy})
	fake.keywordSearchMutex.Unlock()
	if fake.KeywordSearchStub != nil {
		return fake.KeywordSearchStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.keywordSearchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSearcher) KeywordSearchCallCount() int {
	fake.keywordSearchMutex.RLock()
	defer fake.keywordSearchMutex.RUnlock()
	return len(fake.keywordSearchArgsForCall)
}

func (fake *FakeSearcher) KeywordSearchCalls(stub func([]string) ([]models.Object, error)) {
	fake.keywordSearchMutex.Lock()
	defer fake.keywordSearchMutex.Unlock()
	fake.KeywordSearchStub = stub
}

func (fake *FakeSearcher) KeywordSearchArgsForCall(i int) []string {
	fake.keywordSearchMutex.RLock()
	defer fake.keywordSearchMutex.RUnlock()
	argsForCall := fake.keywordSearchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSearcher) KeywordSearchReturns(result1 []models.Object, result2 error) {
	fake.keywordSearchMutex.Lock()
	defer fake.keywordSearchMutex.Unlock()
	fake.KeywordSearchStub = nil
	fake.keywordSearchReturns = struct {
		result1 []models.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) KeywordSearchReturnsOnCall(i int, result1 []models.Object, result2 error) {
	fake.keywordSearchMutex.Lock()
	defer fake.keywordSearchMutex.Unlock()
	fake.KeywordSearchStub = nil
	if fake.keywordSearchReturnsOnCall == nil {
		fake.keywordSearchReturnsOnCall = make(map[int]struct {
			result1 []models.Object
			result2 error
		})
	}
	fake.keywordSearchReturnsOnCall[i] = struct {
		result1 []models.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeSearcher) MigrateEntries(arg1 []query.Entry, arg2 *rtfs.IpfsManager, arg3 bool) error {
	var arg1Copy []query.Entry
	if arg1 != nil {
		arg1Copy = make([]query.Entry, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.migrateEntriesMutex.Lock()
	ret, specificReturn := fake.migrateEntriesReturnsOnCall[len(fake.migrateEntriesArgsForCall)]
	fake.migrateEntriesArgsForCall = append(fake.migrateEntriesArgsForCall, struct {
		arg1 []query.Entry
		arg2 *rtfs.IpfsManager
		arg3 bool
	}{arg1Copy, arg2, arg3})
	fake.recordInvocation("MigrateEntries", []interface{}{arg1Copy, arg2, arg3})
	fake.migrateEntriesMutex.Unlock()
	if fake.MigrateEntriesStub != nil {
		return fake.MigrateEntriesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateEntriesReturns
	return fakeReturns.result1
}

func (fake *FakeSearcher) MigrateEntriesCallCount() int {
	fake.migrateEntriesMutex.RLock()
	defer fake.migrateEntriesMutex.RUnlock()
	return len(fake.migrateEntriesArgsForCall)
}

func (fake *FakeSearcher) MigrateEntriesCalls(stub func([]query.Entry, *rtfs.IpfsManager, bool) error) {
	fake.migrateEntriesMutex.Lock()
	defer fake.migrateEntriesMutex.Unlock()
	fake.MigrateEntriesStub = stub
}

func (fake *FakeSearcher) MigrateEntriesArgsForCall(i int) ([]query.Entry, *rtfs.IpfsManager, bool) {
	fake.migrateEntriesMutex.RLock()
	defer fake.migrateEntriesMutex.RUnlock()
	argsForCall := fake.migrateEntriesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSearcher) MigrateEntriesReturns(result1 error) {
	fake.migrateEntriesMutex.Lock()
	defer fake.migrateEntriesMutex.Unlock()
	fake.MigrateEntriesStub = nil
	fake.migrateEntriesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) MigrateEntriesReturnsOnCall(i int, result1 error) {
	fake.migrateEntriesMutex.Lock()
	defer fake.migrateEntriesMutex.Unlock()
	fake.MigrateEntriesStub = nil
	if fake.migrateEntriesReturnsOnCall == nil {
		fake.migrateEntriesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateEntriesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) Put(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("Put", []interface{}{arg1, arg2Copy})
	fake.putMutex.Unlock()
	if fake.PutStub != nil {
		return fake.PutStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.putReturns
	return fakeReturns.result1
}

func (fake *FakeSearcher) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeSearcher) PutCalls(stub func(string, []byte) error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *FakeSearcher) PutArgsForCall(i int) (string, []byte) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSearcher) PutReturns(result1 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) PutReturnsOnCall(i int, result1 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSearcher) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.advancedSearchMutex.RLock()
	defer fake.advancedSearchMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getEntriesMutex.RLock()
	defer fake.getEntriesMutex.RUnlock()
	fake.hasMutex.RLock()
	defer fake.hasMutex.RUnlock()
	fake.keywordSearchMutex.RLock()
	defer fake.keywordSearchMutex.RUnlock()
	fake.migrateEntriesMutex.RLock()
	defer fake.migrateEntriesMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSearcher) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ search.Searcher = new(FakeSearcher)
